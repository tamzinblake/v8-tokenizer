;;; `zzz-token-x' is a function that returns an `x' token based on the string
;;; passed to it.
;;; `zzz-token-process-x' is a function that attempts to tokenize the next bit
;;; of the buffer as an `x' token based on the position of the cursor.
;;; `zzz-x-start-p' is a function that takes a character and returns
;;; whether the character is appropriate to start an `x' token.
;;; `zzz-CamelCase' is a constant representing a production of the JS grammar.
;;; Note that while all productions are defined here, not all are used.
;;; `zzz-ALL_CAPS' is a constant representing something that is not
;;; a production of the JS grammar, usually a single character

(eval-when-compile
  (require 'cl))

(defmacro deflocal (name value &optional comment)
  `(progn
     (defvar ,name ,value ,comment)
     (make-variable-buffer-local ',name)))

(defvar zzz-ERROR -1)
(defvar zzz-EOF 0)
(defvar zzz-SourceCharacter 1)
(defvar zzz-InputElementDiv 2)
(defvar zzz-InputElementRegExp 3)
(defvar zzz-WhiteSpace 4)
(defvar zzz-LineTerminator 5)
(defvar zzz-LineTerminatorSequence 6)
(defvar zzz-Comment 7)
(defvar zzz-MultiLineComment 8)
(defvar zzz-MultiLineCommentChars 9)
(defvar zzz-PostAsteriskCommentChars 10)
(defvar zzz-MultiLineNotAsteriskChar 11)
(defvar zzz-MultiLineNotForwardSlashOrAsteriskChar 12)
(defvar zzz-SingleLineComment 13)
(defvar zzz-SingleLineCommentChars 14)
(defvar zzz-SingleLineCommentChar 15)
(defvar zzz-Token 16)
(defvar zzz-Identifier 17)
(defvar zzz-IdentifierName 18)
(defvar zzz-IdentifierStart 19)
(defvar zzz-IdentifierPart 20)
(defvar zzz-UnicodeLetter 21)
(defvar zzz-UnicodeCombiningMark 22)
(defvar zzz-UnicodeDigit 23)
(defvar zzz-UnicodeConnectorPunctuation 24)
(defvar zzz-ReservedWord 25)
(defvar zzz-Keyword 26)
(defvar zzz-FutureReservedWord 27)
(defvar zzz-Punctuator 28)
(defvar zzz-DivPunctuator 29)
(defvar zzz-Literal 30)
(defvar zzz-NullLiteral 31)
(defvar zzz-BooleanLiteral 32)
(defvar zzz-NumericLiteral 33)
(defvar zzz-DecimalLiteral 34)
(defvar zzz-DecimalIntegerLiteral 35)
(defvar zzz-DecimalDigits 36)
(defvar zzz-DecimalDigit 37)
(defvar zzz-NonZeroDigit 38)
(defvar zzz-ExponentPart 39)
(defvar zzz-ExponentIndicator 40)
(defvar zzz-SignedInteger 41)
(defvar zzz-HexIntegerLiteral 42)
(defvar zzz-HexDigit 43)
(defvar zzz-StringLiteral 44)
(defvar zzz-DoubleStringCharacters 45)
(defvar zzz-SingleStringCharacters 46)
(defvar zzz-DoubleStringCharacter 47)
(defvar zzz-SingleStringCharacter 48)
(defvar zzz-LineContinuation 49)
(defvar zzz-EscapeSequence 50)
(defvar zzz-CharacterEscapeSequence 51)
(defvar zzz-SingleEscapeCharacter 52)
(defvar zzz-NonEscapeCharacter 53)
(defvar zzz-EscapeCharacter 54)
(defvar zzz-HexEscapeSequence 55)
(defvar zzz-UnicodeEscapeSequence 56)
(defvar zzz-RegularExpressionLiteral 57)
(defvar zzz-RegularExpressionBody 58)
(defvar zzz-RegularExpressionChars 59)
(defvar zzz-RegularExpressionFirstChar 60)
(defvar zzz-RegularExpressionChar 61)
(defvar zzz-RegularExpressionBackslashSequence 62)
(defvar zzz-RegularExpressionNonTerminator 63)
(defvar zzz-RegularExpressionClass 64)
(defvar zzz-RegularExpressionClassChars 65)
(defvar zzz-RegularExpressionClassChar 66)
(defvar zzz-RegularExpressionFlags 67)
(defvar zzz-StringNumericLiteral 68)
(defvar zzz-StrWhiteSpace 69)
(defvar zzz-StrWhiteSpaceChar 70)
(defvar zzz-StrNumericLiteral 71)
(defvar zzz-StrDecimalLiteral 72)
(defvar zzz-StrUnsignedDecimalLiteral 73)
(defvar zzz-DecimalDigits 74)
(defvar zzz-DecimalDigit 75)
(defvar zzz-ExponentPart 76)
(defvar zzz-ExponentIndicator 77)
(defvar zzz-SignedInteger 78)
(defvar zzz-HexIntegerLiteral 79)
(defvar zzz-HexDigit 80)
(defvar zzz-PrimaryExpression 81)
(defvar zzz-ArrayLiteral 82)
(defvar zzz-ElementList 83)
(defvar zzz-Elision 84)
(defvar zzz-ObjectLiteral 85)
(defvar zzz-PropertyNameAndValueList 86)
(defvar zzz-PropertyAssignment 87)
(defvar zzz-PropertyName 88)
(defvar zzz-PropertySetParameterList 89)
(defvar zzz-MemberExpression 90)
(defvar zzz-NewExpression 91)
(defvar zzz-CallExpression 92)
(defvar zzz-Arguments 93)
(defvar zzz-ArgumentList 94)
(defvar zzz-LeftHandSideExpression 95)
(defvar zzz-PostfixExpression 96)
(defvar zzz-UnaryExpression 97)
(defvar zzz-MultiplicativeExpression 98)
(defvar zzz-AdditiveExpression 99)
(defvar zzz-ShiftExpression 100)
(defvar zzz-RelationalExpression 101)
(defvar zzz-RelationalExpressionNoIn 102)
(defvar zzz-EqualityExpression 103)
(defvar zzz-EqualityExpressionNoIn 104)
(defvar zzz-BitwiseANDExpression 105)
(defvar zzz-BitwiseANDExpressionNoIn 106)
(defvar zzz-BitwiseXORExpression 107)
(defvar zzz-BitwiseXORExpressionNoIn 108)
(defvar zzz-BitwiseORExpression 109)
(defvar zzz-BitwiseORExpressionNoIn 110)
(defvar zzz-LogicalANDExpression 111)
(defvar zzz-LogicalANDExpressionNoIn 112)
(defvar zzz-LogicalORExpression 113)
(defvar zzz-LogicalORExpressionNoIn 114)
(defvar zzz-ConditionalExpression 115)
(defvar zzz-ConditionalExpressionNoIn 116)
(defvar zzz-AssignmentExpression 117)
(defvar zzz-AssignmentExpressionNoIn 118)
(defvar zzz-AssignmentOperator 119)
(defvar zzz-Expression 120)
(defvar zzz-ExpressionNoIn 121)
(defvar zzz-Statement 122)
(defvar zzz-Block 123)
(defvar zzz-StatementList 124)
(defvar zzz-VariableStatement 125)
(defvar zzz-VariableDeclarationList 126)
(defvar zzz-VariableDeclarationListNoIn 127)
(defvar zzz-VariableDeclaration 128)
(defvar zzz-VariableDeclarationNoIn 129)
(defvar zzz-Initialiser 130)
(defvar zzz-InitialiserNoIn 131)
(defvar zzz-EmptyStatement 132)
(defvar zzz-ExpressionStatement 133)
(defvar zzz-IfStatement 134)
(defvar zzz-IterationStatement 135)
(defvar zzz-ContinueStatement 136)
(defvar zzz-BreakStatement 137)
(defvar zzz-ReturnStatement 138)
(defvar zzz-WithStatement 139)
(defvar zzz-SwitchStatement 140)
(defvar zzz-CaseBlock 141)
(defvar zzz-CaseClauses 142)
(defvar zzz-CaseClause 143)
(defvar zzz-DefaultClause 144)
(defvar zzz-LabelledStatement 145)
(defvar zzz-ThrowStatement 146)
(defvar zzz-TryStatement 147)
(defvar zzz-Catch 148)
(defvar zzz-Finally 149)
(defvar zzz-DebuggerStatement 150)
(defvar zzz-FunctionDeclaration 151)
(defvar zzz-FunctionExpression 152)
(defvar zzz-FormalParameterList 153)
(defvar zzz-FunctionBody 154)
(defvar zzz-Program 155)
(defvar zzz-SourceElements 156)
(defvar zzz-SourceElement 157)
(defvar zzz-uri 158)
(defvar zzz-uriCharacters 159)
(defvar zzz-uriCharacter 160)
(defvar zzz-uriReserved 161)
(defvar zzz-uriUnescaped 162)
(defvar zzz-uriEscaped 163)
(defvar zzz-uriAlpha 164)
(defvar zzz-uriMark 165)
(defvar zzz-Pattern 166)
(defvar zzz-Disjunction 167)
(defvar zzz-Alternative 168)
(defvar zzz-Term 169)
(defvar zzz-Assertion 170)
(defvar zzz-Quantifier 171)
(defvar zzz-QuantifierPrefix 172)
(defvar zzz-Atom 173)
(defvar zzz-PatternCharacter 174)
(defvar zzz-AtomEscape 175)
(defvar zzz-CharacterEscape 176)
(defvar zzz-ControlEscape 177)
(defvar zzz-ControlLetter 178)
(defvar zzz-IdentityEscape 179)
(defvar zzz-DecimalEscape 180)
(defvar zzz-CharacterClassEscape 181)
(defvar zzz-CharacterClass 182)
(defvar zzz-ClassRanges 183)
(defvar zzz-NonemptyClassRanges 184)
(defvar zzz-NonemptyClassRangesNoDash 185)
(defvar zzz-ClassAtom 186)
(defvar zzz-ClassAtomNoDash 187)
(defvar zzz-ClassEscape 188)
(defvar zzz-JSONWhiteSpace 189)
(defvar zzz-JSONString 190)
(defvar zzz-JSONStringCharacters 191)
(defvar zzz-JSONStringCharacter 192)
(defvar zzz-JSONEscapeSequence 193)
(defvar zzz-JSONEscapeCharacter 194)
(defvar zzz-JSONNumber 195)
(defvar zzz-JSONFraction 196)
(defvar zzz-JSONNullLiteral 197)
(defvar zzz-JSONBooleanLiteral 198)
(defvar zzz-JSONText 199)
(defvar zzz-JSONValue 200)
(defvar zzz-JSONObject 201)
(defvar zzz-JSONMember 202)
(defvar zzz-JSONMemberList 203)
(defvar zzz-JSONArray 204)
(defvar zzz-JSONElementList 205)
(defvar zzz-DOT 206)
(defvar zzz-OPEN_PAREN 207)
(defvar zzz-CLOSE_PAREN 208)
(defvar zzz-COMMA 209)
(defvar zzz-OPEN_BRACE 210)
(defvar zzz-CLOSE_BRACE 211)
(defvar zzz-OPEN_BRACKET 212)
(defvar zzz-CLOSE_BRACKET 213)
(defvar zzz-SEMICOLON 214)
(defvar zzz-COMMA 215)
(defvar zzz-LESS 216)
(defvar zzz-GREATER 217)
(defvar zzz-LESS_EQ 218)
(defvar zzz-GREATER-EQ 219)
(defvar zzz-EQ 220)
(defvar zzz-NOT_EQ 221)
(defvar zzz-STRICT_EQ 222)
(defvar zzz-STRICT_NOT_EQ 223)
(defvar zzz-PLUS 224)
(defvar zzz-MINUS 225)
(defvar zzz-STAR 226)
(defvar zzz-PERCENT 227)
(defvar zzz-PRE_INC 228)
(defvar zzz-PRE_DEC 229)
(defvar zzz-POST_INC 230)
(defvar zzz-POST_DEC 231)
(defvar zzz-SHIFT_LEFT 232)
(defvar zzz-SHIFT_RIGHT 233)
(defvar zzz-SHIFT_RIGHT_FILL 234)
(defvar zzz-BIT_AND 235)
(defvar zzz-BIT_OR 236)
(defvar zzz-BIT_XOR 237)
(defvar zzz-NOT 238)
(defvar zzz-BIT_NOT 239)
(defvar zzz-AND 240)
(defvar zzz-OR 241)
(defvar zzz-QUES 242)
(defvar zzz-COLON 243)
(defvar zzz-ASSIGN 244)
(defvar zzz-ASSIGN_PLUS 245)
(defvar zzz-ASSIGN_MINUS 246)
(defvar zzz-ASSIGN_STAR 247)
(defvar zzz-ASSIGN_PERCENT 248)
(defvar zzz-ASSIGN_SHIFT_LEFT 249)
(defvar zzz-ASSIGN_SHIFT_RIGHT 250)
(defvar zzz-ASSIGN_SHIFT_RIGHT_FILL 251)
(defvar zzz-ASSIGN_BIT_AND 252)
(defvar zzz-ASSIGN_BIT_OR 253)
(defvar zzz-ASSIGN_BIT_XOR 254)
(defvar zzz-DIV 255)
(defvar zzz-ASSIGN_DIV 256)

(defstruct (zzz-token
	    (:constructor nil))
  "Base Token type."
  (type -1)            ; token type
  (pos -1)             ; start position in buffer
  (len 1)              ; length of token in characters
  (comments-before)    ; comments before the token
  (whitespace-before)) ; whitespace before the token

(defstruct (zzz-regex-token
	    (:include zzz-token)
	    (:constructor nil)
	    (:constructor make-zzz-regex-token
			  (&key (type zzz-RegularExpressionLiteral)
				pos
				len
				comments-before
				whitespace-before
				tokens
				flags)))
  "Token for a RegularExpressionLiteral."
  tokens ; a lisp list of the regex's component tokens
  flags) ; a string of the regex flags

(deflocal zzz-ts-cursor 1 ;emacs buffers are 1-indexed
  "Token stream buffer-local variable.
Current scan position.")

(deflocal zzz-ts-lineno 1 ;emacs buffer lines are 1-indexed
  "Token stream buffer-local variable.
The number of the current line.")

(defsubst zzz-unget-char ()
  (decf zzz-ts-cursor))

(defsubst zzz-get-char ()
  "Read and return the next character from the input buffer.
Increments `zzz-ts-lineno' if the return value is a newline char.
Updates `zzz-ts-cursor' to the point after the returned char.
Returns `zzz-EOF_CHAR' if we hit the end of the buffer."
  (let (c)
    ;; check for end of buffer
    (if (eq zzz-ts-cursor (point-max))
        (setq zzz-ts-cursor (1+ zzz-ts-cursor)
              c zzz-EOF_CHAR)  ; return value
      (if (> zzz-ts-cursor (point-max))
	  (error "Scanned past end of buffer.")
	;; otherwise read next char
	(setq c (char-before (incf zzz-ts-cursor)))
	;; if we read a newline, update counters
	(if (zzz-eol-p c)
	    (setq zzz-ts-lineno (1+ zzz-ts-lineno)))
	c))))

(defsubst zzz-peek-char ()
  "Return the next character, but don't consume it."
  (prog1
      (zzz-get-char)
    (zzz-unget-char)))

(defsubst zzz-match-char (test)
  "Consume and return next character if it matches `test', a character.
Returns nil and consumes nothing if `test' is not the next character."
  (let ((c (zzz-get-char)))
    (if (eq c test)
        c
      (zzz-unget-char)
      nil)))

(defsubst zzz-escape-to-unicode (string)
  "Convert the integer part of a unicode escape sequence into a character."
  (char-to-string (string-to-number string 16)))

(defsubst zzz-read-hex-escape ()
  "Read a \\uNN sequence from the input.
Assumes the ?\ and ?x have already been read.
Returns the unicode character, or nil if it wasn't a valid character.
Doesn't change the values of any scanner variables."
  (ignore-errors
   (let ((s (buffer-substring-no-properties zzz-ts-cursor
                                            (+ 2 zzz-ts-cursor))))
     (if (string-match "[a-fA-F0-9]\\{2\\}" s)
         (zzz-escape-to-unicode s)
       (error "Invalid hex escape sequence")))))

(defsubst zzz-read-unicode-escape ()
  "Read a \\uNNNN sequence from the input.
Assumes the ?\ and ?u have already been read.
Returns the unicode character, or nil if it wasn't a valid character.
Doesn't change the values of any scanner variables."
  (ignore-errors
   (let ((s (buffer-substring-no-properties zzz-ts-cursor
                                            (+ 4 zzz-ts-cursor))))
     (if (string-match "[a-fA-F0-9]\\{4\\}" s)
         (zzz-escape-to-unicode s)
       (error "Invalid unicode escape sequence")))))

(defun zzz-whitespace-p (c)
  "Return whether `c' is a whitespace character."
  (memq c '(#x0009 #x000B #x000C #x0020 #x00A0 #xFEFF #x000A #x000D #x0085
		   #x1680 #x180E #x2000 #x2001 #x2002 #x2003 #x2004 #x2005
		   #x2006 #x2007 #x2008 #x2009 #x200A #x2028 #x2029 #x202F
		   #x205F #x3000)))

(defun zzz-identifier-start-p (c)
  "Return whether `c' is a legal start of an identifier."
  (or (= c $)
      (= c _)
      (and (> c A) (< c Z))
      (and (> c a) (< c z))
      (memq c '(#xaa #xb5 #xba))
      (and (> c #xc0) (< c #xd6))
      (and (> c #xd8) (< c #xf6))
      (and (> c #xf8) (< c #x02c1))
      (and (> c #x02c6) (< c #x02d1))
      (and (> c #x02e0) (< c #x02e4))
      (memq c '(#x02ec #x02ee))
      (and (> c #x0370) (< c #x0374))
      (memq c '(#x0376 #x0377))
      (and (> c #x037a) (< c #x037d))
      (= c #x0386)
      (and (> c #x0388) (< c #x038a))
      (= c #x038c)
      (and (> c #x038e) (< c #x03a1))
      (and (> c #x03a3) (< c #x03f5))
      (and (> c #x03f7) (< c #x0481))
      (and (> c #x048a) (< c #x0527))
      (and (> c #x0531) (< c #x0556))
      (= c #x0559)
      (and (> c #x0561) (< c #x0587))
      (and (> c #x05d0) (< c #x05ea))
      (and (> c #x05f0) (< c #x05f2))
      (and (> c #x0620) (< c #x064a))
      (memq c '(#x066e #x066f))
      (and (> c #x0671) (< c #x06d3))
      (memq c '(#x06d5 #x06e5 #x06e6 #x06ee #x06ef))
      (and (> c #x06fa) (< c #x06fc))
      (memq c '(#x06ff #x0710))
      (and (> c #x0712) (< c #x072f))
      (and (> c #x074d) (< c #x07a5))
      (= c #x07b1)
      (and (> c #x07ca) (< c #x07ea))
      (memq c '(#x07f4 #x07f5 #x07fa))
      (and (> c #x0800) (< c #x0815))
      (memq c '(#x081a #x0824 #x0828))
      (and (> c #x0840) (< c #x0858))
      (= c #x08a0)
      (and (> c #x08a2) (< c #x08ac))
      (and (> c #x0904) (< c #x0939))
      (memq c '(#x093d #x0950))
      (and (> c #x0958) (< c #x0961))
      (and (> c #x0971) (< c #x0977))
      (and (> c #x0979) (< c #x097f))
      (and (> c #x0985) (< c #x098c))
      (memq c '(#x098f #x0990))
      (and (> c #x0993) (< c #x09a8))
      (and (> c #x09aa) (< c #x09b0))
      (= c #x09b2)
      (and (> c #x09b6) (< c #x09b9))
      (memq c '(#x09bd #x09ce #x09dc #x09dd))
      (and (> c #x09df) (< c #x09e1))
      (memq c '(#x09f0 #x09f1))
      (and (> c #x0a05) (< c #x0a0a))
      (memq c '(#x0a0f #x0a10))
      (and (> c #x0a13) (< c #x0a28))
      (and (> c #x0a2a) (< c #x0a30))
      (memq c '(#x0a32 #x0a33 #x0a35 #x0a36 #x0a38 #x0a39))
      (and (> c #x0a59) (< c #x0a5c))
      (= c #x0a5e)
      (and (> c #x0a72) (< c #x0a74))
      (and (> c #x0a85) (< c #x0a8d))
      (and (> c #x0a8f) (< c #x0a91))
      (and (> c #x0a93) (< c #x0aa8))
      (and (> c #x0aaa) (< c #x0ab0))
      (memq c '(#x0ab2 #x0ab3))
      (and (> c #x0ab5) (< c #x0ab9))
      (memq c '(#x0abd #x0ad0 #x0ae0 #x0ae1))
      (and (> c #x0b05) (< c #x0b0c))
      (memq c '(#x0b0f #x0b10))
      (and (> c #x0b13) (< c #x0b28))
      (and (> c #x0b2a) (< c #x0b30))
      (memq c '(#x0b32 #x0b33))
      (and (> c #x0b35) (< c #x0b39))
      (memq c '(#x0b3d #x0b5c #x0b5d))
      (and (> c #x0b5f) (< c #x0b61))
      (memq c '(#x0b71 #x0b83))
      (and (> c #x0b85) (< c #x0b8a))
      (and (> c #x0b8e) (< c #x0b90))
      (and (> c #x0b92) (< c #x0b95))
      (memq c '(#x0b99 #x0b9a #x0b9c #x0b9e #x0b9f #x0ba3 #x0ba4))
      (and (> c #x0ba8) (< c #x0baa))
      (and (> c #x0bae) (< c #x0bb9))
      (= c #x0bd0)
      (and (> c #x0c05) (< c #x0c0c))
      (and (> c #x0c0e) (< c #x0c10))
      (and (> c #x0c12) (< c #x0c28))
      (and (> c #x0c2a) (< c #x0c33))
      (and (> c #x0c35) (< c #x0c39))
      (memq c '(#x0c3d #x0c58 #x0c59 #x0c60 #x0c61))
      (and (> c #x0c85) (< c #x0c8c))
      (and (> c #x0c8e) (< c #x0c90))
      (and (> c #x0c92) (< c #x0ca8))
      (and (> c #x0caa) (< c #x0cb3))
      (and (> c #x0cb5) (< c #x0cb9))
      (memq c '(#x0cbd #x0cde #x0ce0 #x0ce1 #x0cf1 #x0cf2))
      (and (> c #x0d05) (< c #x0d0c))
      (and (> c #x0d0e) (< c #x0d10))
      (and (> c #x0d12) (< c #x0d3a))
      (memq c '(#x0d3d #x0d4e #x0d60 #x0d61))
      (and (> c #x0d7a) (< c #x0d7f))
      (and (> c #x0d85) (< c #x0d96))
      (and (> c #x0d9a) (< c #x0db1))
      (and (> c #x0db3) (< c #x0dbb))
      (= c #x0dbd)
      (and (> c #x0dc0) (< c #x0dc6))
      (and (> c #x0e01) (< c #x0e30))
      (memq c '(#x0e32 #x0e33))
      (and (> c #x0e40) (< c #x0e46))
      (memq c '(#x0e81 #x0e82 #x0e84 #x0e87 #x0e88 #x0e8a #x0e8d))
      (and (> c #x0e94) (< c #x0e97))
      (and (> c #x0e99) (< c #x0e9f))
      (and (> c #x0ea1) (< c #x0ea3))
      (memq c '(#x0ea5 #x0ea7 #x0eaa #x0eab))
      (and (> c #x0ead) (< c #x0eb0))
      (memq c '(#x0eb2 #x0eb3 #x0ebd))
      (and (> c #x0ec0) (< c #x0ec4))
      (= c #x0ec6)
      (and (> c #x0edc) (< c #x0edf))
      (= c #x0f00)
      (and (> c #x0f40) (< c #x0f47))
      (and (> c #x0f49) (< c #x0f6c))
      (and (> c #x0f88) (< c #x0f8c))
      (and (> c #x1000) (< c #x102a))
      (= c #x103f)
      (and (> c #x1050) (< c #x1055))
      (and (> c #x105a) (< c #x105d))
      (memq c '(#x1061 #x1065 #x1066))
      (and (> c #x106e) (< c #x1070))
      (and (> c #x1075) (< c #x1081))
      (= c #x108e)
      (and (> c #x10a0) (< c #x10c5))
      (memq c '(#x10c7 #x10cd))
      (and (> c #x10d0) (< c #x10fa))
      (and (> c #x10fc) (< c #x1248))
      (and (> c #x124a) (< c #x124d))
      (and (> c #x1250) (< c #x1256))
      (= c #x1258)
      (and (> c #x125a) (< c #x125d))
      (and (> c #x1260) (< c #x1288))
      (and (> c #x128a) (< c #x128d))
      (and (> c #x1290) (< c #x12b0))
      (and (> c #x12b2) (< c #x12b5))
      (and (> c #x12b8) (< c #x12be))
      (= c #x12c0)
      (and (> c #x12c2) (< c #x12c5))
      (and (> c #x12c8) (< c #x12d6))
      (and (> c #x12d8) (< c #x1310))
      (and (> c #x1312) (< c #x1315))
      (and (> c #x1318) (< c #x135a))
      (and (> c #x1380) (< c #x138f))
      (and (> c #x13a0) (< c #x13f4))
      (and (> c #x1401) (< c #x166c))
      (and (> c #x166f) (< c #x167f))
      (and (> c #x1681) (< c #x169a))
      (and (> c #x16a0) (< c #x16ea))
      (and (> c #x16ee) (< c #x16f0))
      (and (> c #x1700) (< c #x170c))
      (and (> c #x170e) (< c #x1711))
      (and (> c #x1720) (< c #x1731))
      (and (> c #x1740) (< c #x1751))
      (and (> c #x1760) (< c #x176c))
      (and (> c #x176e) (< c #x1770))
      (and (> c #x1780) (< c #x17b3))
      (memq c '(#x17d7 #x17dc))
      (and (> c #x1820) (< c #x1877))
      (and (> c #x1880) (< c #x18a8))
      (= c #x18aa)
      (and (> c #x18b0) (< c #x18f5))
      (and (> c #x1900) (< c #x191c))
      (and (> c #x1950) (< c #x196d))
      (and (> c #x1970) (< c #x1974))
      (and (> c #x1980) (< c #x19ab))
      (and (> c #x19c1) (< c #x19c7))
      (and (> c #x1a00) (< c #x1a16))
      (and (> c #x1a20) (< c #x1a54))
      (= c #x1aa7)
      (and (> c #x1b05) (< c #x1b33))
      (and (> c #x1b45) (< c #x1b4b))
      (and (> c #x1b83) (< c #x1ba0))
      (memq c '(#x1bae #x1baf))
      (and (> c #x1bba) (< c #x1be5))
      (and (> c #x1c00) (< c #x1c23))
      (and (> c #x1c4d) (< c #x1c4f))
      (and (> c #x1c5a) (< c #x1c7d))
      (and (> c #x1ce9) (< c #x1cec))
      (and (> c #x1cee) (< c #x1cf1))
      (memq c '(#x1cf5 #x1cf6))
      (and (> c #x1d00) (< c #x1dbf))
      (and (> c #x1e00) (< c #x1f15))
      (and (> c #x1f18) (< c #x1f1d))
      (and (> c #x1f20) (< c #x1f45))
      (and (> c #x1f48) (< c #x1f4d))
      (and (> c #x1f50) (< c #x1f57))
      (memq c '(#x1f59 #x1f5b #x1f5d))
      (and (> c #x1f5f) (< c #x1f7d))
      (and (> c #x1f80) (< c #x1fb4))
      (and (> c #x1fb6) (< c #x1fbc))
      (= c #x1fbe)
      (and (> c #x1fc2) (< c #x1fc4))
      (and (> c #x1fc6) (< c #x1fcc))
      (and (> c #x1fd0) (< c #x1fd3))
      (and (> c #x1fd6) (< c #x1fdb))
      (and (> c #x1fe0) (< c #x1fec))
      (and (> c #x1ff2) (< c #x1ff4))
      (and (> c #x1ff6) (< c #x1ffc))
      (memq c '(#x2071 #x207f))
      (and (> c #x2090) (< c #x209c))
      (memq c '(#x2102 #x2107))
      (and (> c #x210a) (< c #x2113))
      (= c #x2115)
      (and (> c #x2119) (< c #x211d))
      (memq c '(#x2124 #x2126 #x2128))
      (and (> c #x212a) (< c #x212d))
      (and (> c #x212f) (< c #x2139))
      (and (> c #x213c) (< c #x213f))
      (and (> c #x2145) (< c #x2149))
      (= c #x214e)
      (and (> c #x2160) (< c #x2188))
      (and (> c #x2c00) (< c #x2c2e))
      (and (> c #x2c30) (< c #x2c5e))
      (and (> c #x2c60) (< c #x2ce4))
      (and (> c #x2ceb) (< c #x2cee))
      (memq c '(#x2cf2 #x2cf3))
      (and (> c #x2d00) (< c #x2d25))
      (memq c '(#x2d27 #x2d2d))
      (and (> c #x2d30) (< c #x2d67))
      (= c #x2d6f)
      (and (> c #x2d80) (< c #x2d96))
      (and (> c #x2da0) (< c #x2da6))
      (and (> c #x2da8) (< c #x2dae))
      (and (> c #x2db0) (< c #x2db6))
      (and (> c #x2db8) (< c #x2dbe))
      (and (> c #x2dc0) (< c #x2dc6))
      (and (> c #x2dc8) (< c #x2dce))
      (and (> c #x2dd0) (< c #x2dd6))
      (and (> c #x2dd8) (< c #x2dde))
      (= c #x2e2f)
      (and (> c #x3005) (< c #x3007))
      (and (> c #x3021) (< c #x3029))
      (and (> c #x3031) (< c #x3035))
      (and (> c #x3038) (< c #x303c))
      (and (> c #x3041) (< c #x3096))
      (and (> c #x309d) (< c #x309f))
      (and (> c #x30a1) (< c #x30fa))
      (and (> c #x30fc) (< c #x30ff))
      (and (> c #x3105) (< c #x312d))
      (and (> c #x3131) (< c #x318e))
      (and (> c #x31a0) (< c #x31ba))
      (and (> c #x31f0) (< c #x31ff))
      (and (> c #x3400) (< c #x4db5))
      (and (> c #x4e00) (< c #x9fcc))
      (and (> c #xa000) (< c #xa48c))
      (and (> c #xa4d0) (< c #xa4fd))
      (and (> c #xa500) (< c #xa60c))
      (and (> c #xa610) (< c #xa61f))
      (memq c '(#xa62a #xa62b))
      (and (> c #xa640) (< c #xa66e))
      (and (> c #xa67f) (< c #xa697))
      (and (> c #xa6a0) (< c #xa6ef))
      (and (> c #xa717) (< c #xa71f))
      (and (> c #xa722) (< c #xa788))
      (and (> c #xa78b) (< c #xa78e))
      (and (> c #xa790) (< c #xa793))
      (and (> c #xa7a0) (< c #xa7aa))
      (and (> c #xa7f8) (< c #xa801))
      (and (> c #xa803) (< c #xa805))
      (and (> c #xa807) (< c #xa80a))
      (and (> c #xa80c) (< c #xa822))
      (and (> c #xa840) (< c #xa873))
      (and (> c #xa882) (< c #xa8b3))
      (and (> c #xa8f2) (< c #xa8f7))
      (= c #xa8fb)
      (and (> c #xa90a) (< c #xa925))
      (and (> c #xa930) (< c #xa946))
      (and (> c #xa960) (< c #xa97c))
      (and (> c #xa984) (< c #xa9b2))
      (= c #xa9cf)
      (and (> c #xaa00) (< c #xaa28))
      (and (> c #xaa40) (< c #xaa42))
      (and (> c #xaa44) (< c #xaa4b))
      (and (> c #xaa60) (< c #xaa76))
      (= c #xaa7a)
      (and (> c #xaa80) (< c #xaaaf))
      (memq c '(#xaab1 #xaab5 #xaab6))
      (and (> c #xaab9) (< c #xaabd))
      (memq c '(#xaac0 #xaac2))
      (and (> c #xaadb) (< c #xaadd))
      (and (> c #xaae0) (< c #xaaea))
      (and (> c #xaaf2) (< c #xaaf4))
      (and (> c #xab01) (< c #xab06))
      (and (> c #xab09) (< c #xab0e))
      (and (> c #xab11) (< c #xab16))
      (and (> c #xab20) (< c #xab26))
      (and (> c #xab28) (< c #xab2e))
      (and (> c #xabc0) (< c #xabe2))
      (and (> c #xac00) (< c #xd7a3))
      (and (> c #xd7b0) (< c #xd7c6))
      (and (> c #xd7cb) (< c #xd7fb))
      (and (> c #xf900) (< c #xfa6d))
      (and (> c #xfa70) (< c #xfad9))
      (and (> c #xfb00) (< c #xfb06))
      (and (> c #xfb13) (< c #xfb17))
      (= c #xfb1d)
      (and (> c #xfb1f) (< c #xfb28))
      (and (> c #xfb2a) (< c #xfb36))
      (and (> c #xfb38) (< c #xfb3c))
      (memq c '(#xfb3e #xfb40 #xfb41 #xfb43 #xfb44))
      (and (> c #xfb46) (< c #xfbb1))
      (and (> c #xfbd3) (< c #xfd3d))
      (and (> c #xfd50) (< c #xfd8f))
      (and (> c #xfd92) (< c #xfdc7))
      (and (> c #xfdf0) (< c #xfdfb))
      (and (> c #xfe70) (< c #xfe74))
      (and (> c #xfe76) (< c #xfefc))
      (and (> c #xff21) (< c #xff3a))
      (and (> c #xff41) (< c #xff5a))
      (and (> c #xff66) (< c #xffbe))
      (and (> c #xffc2) (< c #xffc7))
      (and (> c #xffca) (< c #xffcf))
      (and (> c #xffd2) (< c #xffd7))
      (and (> c #xffda) (< c #xffdc))))

(defun zzz-identifier-part-p (c)
  "Return whether `c' is a legal character in an identifier."
  (or (zzz-identifier-start-p c)
      (and (> c ?0) (< c 9))
      (and (> c #x0300) (< c #x036f))
      (and (> c #x0483) (< c #x0487))
      (and (> c #x0591) (< c #x05bd))
      (memq c '(#x05bf #x05c1 #x05c2 #x05c4 #x05c5 #x05c7))
      (and (> c #x0610) (< c #x061a))
      (and (> c #x064b) (< c #x0669))
      (= c #x0670)
      (and (> c #x06d6) (< c #x06dc))
      (and (> c #x06df) (< c #x06e4))
      (memq c '(#x06e7 #x06e8))
      (and (> c #x06ea) (< c #x06ed))
      (and (> c #x06f0) (< c #x06f9))
      (= c #x0711)
      (and (> c #x0730) (< c #x074a))
      (and (> c #x07a6) (< c #x07b0))
      (and (> c #x07c0) (< c #x07c9))
      (and (> c #x07eb) (< c #x07f3))
      (and (> c #x0816) (< c #x0819))
      (and (> c #x081b) (< c #x0823))
      (and (> c #x0825) (< c #x0827))
      (and (> c #x0829) (< c #x082d))
      (and (> c #x0859) (< c #x085b))
      (and (> c #x08e4) (< c #x08fe))
      (and (> c #x0900) (< c #x0903))
      (and (> c #x093a) (< c #x093c))
      (and (> c #x093e) (< c #x094f))
      (and (> c #x0951) (< c #x0957))
      (memq c '(#x0962 #x0963))
      (and (> c #x0966) (< c #x096f))
      (and (> c #x0981) (< c #x0983))
      (= c #x09bc)
      (and (> c #x09be) (< c #x09c4))
      (memq c '(#x09c7 #x09c8))
      (and (> c #x09cb) (< c #x09cd))
      (memq c '(#x09d7 #x09e2 #x09e3))
      (and (> c #x09e6) (< c #x09ef))
      (and (> c #x0a01) (< c #x0a03))
      (= c #x0a3c)
      (and (> c #x0a3e) (< c #x0a42))
      (memq c '(#x0a47 #x0a48))
      (and (> c #x0a4b) (< c #x0a4d))
      (= c #x0a51)
      (and (> c #x0a66) (< c #x0a71))
      (= c #x0a75)
      (and (> c #x0a81) (< c #x0a83))
      (= c #x0abc)
      (and (> c #x0abe) (< c #x0ac5))
      (and (> c #x0ac7) (< c #x0ac9))
      (and (> c #x0acb) (< c #x0acd))
      (memq c '(#x0ae2 #x0ae3))
      (and (> c #x0ae6) (< c #x0aef))
      (and (> c #x0b01) (< c #x0b03))
      (= c #x0b3c)
      (and (> c #x0b3e) (< c #x0b44))
      (memq c '(#x0b47 #x0b48))
      (and (> c #x0b4b) (< c #x0b4d))
      (memq c '(#x0b56 #x0b57 #x0b62 #x0b63))
      (and (> c #x0b66) (< c #x0b6f))
      (= c #x0b82)
      (and (> c #x0bbe) (< c #x0bc2))
      (and (> c #x0bc6) (< c #x0bc8))
      (and (> c #x0bca) (< c #x0bcd))
      (= c #x0bd7)
      (and (> c #x0be6) (< c #x0bef))
      (and (> c #x0c01) (< c #x0c03))
      (and (> c #x0c3e) (< c #x0c44))
      (and (> c #x0c46) (< c #x0c48))
      (and (> c #x0c4a) (< c #x0c4d))
      (memq c '(#x0c55 #x0c56 #x0c62 #x0c63))
      (and (> c #x0c66) (< c #x0c6f))
      (memq c '(#x0c82 #x0c83 #x0cbc))
      (and (> c #x0cbe) (< c #x0cc4))
      (and (> c #x0cc6) (< c #x0cc8))
      (and (> c #x0cca) (< c #x0ccd))
      (memq c '(#x0cd5 #x0cd6 #x0ce2 #x0ce3))
      (and (> c #x0ce6) (< c #x0cef))
      (memq c '(#x0d02 #x0d03))
      (and (> c #x0d3e) (< c #x0d44))
      (and (> c #x0d46) (< c #x0d48))
      (and (> c #x0d4a) (< c #x0d4d))
      (memq c '(#x0d57 #x0d62 #x0d63))
      (and (> c #x0d66) (< c #x0d6f))
      (memq c '(#x0d82 #x0d83 #x0dca))
      (and (> c #x0dcf) (< c #x0dd4))
      (= c #x0dd6)
      (and (> c #x0dd8) (< c #x0ddf))
      (memq c '(#x0df2 #x0df3 #x0e31))
      (and (> c #x0e34) (< c #x0e3a))
      (and (> c #x0e47) (< c #x0e4e))
      (and (> c #x0e50) (< c #x0e59))
      (= c #x0eb1)
      (and (> c #x0eb4) (< c #x0eb9))
      (memq c '(#x0ebb #x0ebc))
      (and (> c #x0ec8) (< c #x0ecd))
      (and (> c #x0ed0) (< c #x0ed9))
      (memq c '(#x0f18 #x0f19))
      (and (> c #x0f20) (< c #x0f29))
      (memq c '(#x0f35 #x0f37 #x0f39 #x0f3e #x0f3f))
      (and (> c #x0f71) (< c #x0f84))
      (memq c '(#x0f86 #x0f87))
      (and (> c #x0f8d) (< c #x0f97))
      (and (> c #x0f99) (< c #x0fbc))
      (= c #x0fc6)
      (and (> c #x102b) (< c #x103e))
      (and (> c #x1040) (< c #x1049))
      (and (> c #x1056) (< c #x1059))
      (and (> c #x105e) (< c #x1060))
      (and (> c #x1062) (< c #x1064))
      (and (> c #x1067) (< c #x106d))
      (and (> c #x1071) (< c #x1074))
      (and (> c #x1082) (< c #x108d))
      (and (> c #x108f) (< c #x109d))
      (and (> c #x135d) (< c #x135f))
      (and (> c #x1712) (< c #x1714))
      (and (> c #x1732) (< c #x1734))
      (memq c '(#x1752 #x1753 #x1772 #x1773))
      (and (> c #x17b4) (< c #x17d3))
      (= c #x17dd)
      (and (> c #x17e0) (< c #x17e9))
      (and (> c #x180b) (< c #x180d))
      (and (> c #x1810) (< c #x1819))
      (= c #x18a9)
      (and (> c #x1920) (< c #x192b))
      (and (> c #x1930) (< c #x193b))
      (and (> c #x1946) (< c #x194f))
      (and (> c #x19b0) (< c #x19c0))
      (memq c '(#x19c8 #x19c9))
      (and (> c #x19d0) (< c #x19d9))
      (and (> c #x1a17) (< c #x1a1b))
      (and (> c #x1a55) (< c #x1a5e))
      (and (> c #x1a60) (< c #x1a7c))
      (and (> c #x1a7f) (< c #x1a89))
      (and (> c #x1a90) (< c #x1a99))
      (and (> c #x1b00) (< c #x1b04))
      (and (> c #x1b34) (< c #x1b44))
      (and (> c #x1b50) (< c #x1b59))
      (and (> c #x1b6b) (< c #x1b73))
      (and (> c #x1b80) (< c #x1b82))
      (and (> c #x1ba1) (< c #x1bad))
      (and (> c #x1bb0) (< c #x1bb9))
      (and (> c #x1be6) (< c #x1bf3))
      (and (> c #x1c24) (< c #x1c37))
      (and (> c #x1c40) (< c #x1c49))
      (and (> c #x1c50) (< c #x1c59))
      (and (> c #x1cd0) (< c #x1cd2))
      (and (> c #x1cd4) (< c #x1ce8))
      (= c #x1ced)
      (and (> c #x1cf2) (< c #x1cf4))
      (and (> c #x1dc0) (< c #x1de6))
      (and (> c #x1dfc) (< c #x1dff))
      (memq c '(#x200c #x200d #x203f #x2040 #x2054))
      (and (> c #x20d0) (< c #x20dc))
      (= c #x20e1)
      (and (> c #x20e5) (< c #x20f0))
      (and (> c #x2cef) (< c #x2cf1))
      (= c #x2d7f)
      (and (> c #x2de0) (< c #x2dff))
      (and (> c #x302a) (< c #x302f))
      (memq c '(#x3099 #x309a))
      (and (> c #xa620) (< c #xa629))
      (= c #xa66f)
      (and (> c #xa674) (< c #xa67d))
      (memq c '(#xa69f #xa6f0 #xa6f1 #xa802 #xa806 #xa80b))
      (and (> c #xa823) (< c #xa827))
      (memq c '(#xa880 #xa881))
      (and (> c #xa8b4) (< c #xa8c4))
      (and (> c #xa8d0) (< c #xa8d9))
      (and (> c #xa8e0) (< c #xa8f1))
      (and (> c #xa900) (< c #xa909))
      (and (> c #xa926) (< c #xa92d))
      (and (> c #xa947) (< c #xa953))
      (and (> c #xa980) (< c #xa983))
      (and (> c #xa9b3) (< c #xa9c0))
      (and (> c #xa9d0) (< c #xa9d9))
      (and (> c #xaa29) (< c #xaa36))
      (memq c '(#xaa43 #xaa4c #xaa4d))
      (and (> c #xaa50) (< c #xaa59))
      (memq c '(#xaa7b #xaab0))
      (and (> c #xaab2) (< c #xaab4))
      (memq c '(#xaab7 #xaab8 #xaabe #xaabf #xaac1))
      (and (> c #xaaeb) (< c #xaaef))
      (memq c '(#xaaf5 #xaaf6))
      (and (> c #xabe3) (< c #xabea))
      (memq c '(#xabec #xabed))
      (and (> c #xabf0) (< c #xabf9))
      (= c #xfb1e)
      (and (> c #xfe00) (< c #xfe0f))
      (and (> c #xfe20) (< c #xfe26))
      (memq c '(#xfe33 #xfe34))
      (and (> c #xfe4d) (< c #xfe4f))
      (and (> c #xff10) (< c #xff19))
      (= c #xff3f)))

(defun zzz-eol-p (c)
  "Return whether `c' is an eol character.
For parsing, remember to lookahead for <cr><lf>.
Note that in Emacs, you should only see \\n at the end of a line."
  (memq c '(#x000A #x000D #x2028 #x2029)))

(defun zzz-decimal-digits-start-p (c)
  "Return whether `c' is a legal start of DecimalDigits."
  (and (<= ?0 c) (<= c ?9)))

(defun zzz-numeric-literal-start-p (c)
  "Return whether `c' is a legal start of a NumericLiteral other than `.'."
  (and (<= ?0 c) (<= c ?9)))

(defun zzz-punctuator-start-p (c)
  "Return whether `c' is a legal start of a Punctuator."
  (and (memq c "{}()[].;,<>=!+-*%&|^~?:/") t))

(defun zzz-keyword-p (str)
  "Return whether `str' is a Keyword."
  (memq str '("break" "case" "catch" "continue" "debugger" "default" "delete" "do" "else" "finally" "for" "function" "if" "in" "instanceof" "new" "return" "switch" "this" "throw" "try" "typeof" "var" "void" "while" "with")))

(defun zzz-future-reserved-word-p (str)
  "Return whether `str' is a FutureReservedWord."
  (memq str '("class" "const" "enum" "export" "extends" "import" "super")))

(defun zzz-null-literal-p (str)
  "Return whether `str' is a NullLiteral."
  (eq str "null"))

(defun zzz-boolean-literal-p (str)
  "Return whether `str' is a BooleanLiteral."
  (memq str '("true" "false")))

(defun zzz-reserved-word-p (str)
  "Return whether `str' is a ReservedWord."
  (or (zzz-keyword-p str)
      (zzz-future-reserved-word-p str)
      (zzz-null-literal-p str)
      (zzz-boolean-literal-p str)))

(defun zzz-token-eof (c)
  "Return standard eof token.")

(defun zzz-token-eol (str)
  "Return standard eol token.
For this tokenizer, eol is considered a proper token.")

(defun zzz-token-string-literal (str quotes)
  "Return string token containing `str' and surrounded by `quotes'.")

(defun zzz-token-identifier (str)
  "Return identifier token based on `str'.")

(defun zzz-token-reserved-word (str)
  "Return reserved word token based on `str'.")

(defun zzz-token-decimal-literal (str)
  "Return numeric literal token based on `str'.
Where `str' is definitely a valid js non-hex numeric literal.")

(defun zzz-token-hex-literal (str)
  "Return numeric literal token based on `str'.
Where `str' is definitely a valid js hex numeric literal.")

(defun zzz-token-process-identifier (c)
  "Return identifier token starting with `c'."
  (when (not (zzz-identifier-start-p c))
    (error "Invalid identifier start character somehow."))
  (let ((identifier-string (string c))
	(token nil)
	(c c))
    (while (zzz-identifier-part-p c)
      (setq c (zzz-get-char))
      (if (zzz-identifier-part-p c)
	  (setq identifier-string (concat identifier-string (string c)))))
    (zzz-unget-char)
    (if (zzz-reserved-word-p identifier-string)
	(setq token (zzz-token-reserved-word identifier-string))
      (setq token (zzz-token-identifier identifier-string)))
    token))

(defun zzz-token-process-numeric-literal (c)
  "Return numeric literal token starting with `c'."
  (backwards-char 1)
  (let ((m "")
	(token nil))
    (cond
     ((looking-at "\\(\\(0|[1-9][0-9]*\\)?\\([.][0-9]+\\)?\\([eE](+|-)?[0-9]+\\)?\\)")
      (setq m (match-string-no-properties 1))
      (forward-char (length m))
      (setq token (zzz-token-decimal-literal m)))
     ((looking-at "\\(0[x|X][0-9a-fA-F]+\\)")
      (setq m (match-string-no-properties 1))
      (forward-char (length m))
      (setq token (zzz-token-hex-literal m)))
     (t
      (error "Invalid numeric literal somehow.")))
    (let ((p (zzz-peek-char)))
      (if (or (zzz-identifier-start-p p)
	      (zzz-decimal-digits-start-p p))
	  (error "Invalid numeric literal")
	token))))

(defun zzz-token-process-string-literal (c)
  "Return string literal token starting with `c'."
  (let ((string-start c)
	(string-contents "")
	(continue t)
	(c nil)
	(token nil))
    (while continue
      (setq c (zzz-get-char))
      (cond
       ((eq c string-start)
	(setq continue nil)
	(setq token (zzz-token-string-literal string-contents c)))
       ((zzz-eol-p c)
	(error "Newline in string literal."))
       ((eq c ?\\)
	(let ((c2 (zzz-get-char)))
	  (cond
	   ((eq c2 ?u)
	    (setq string-contents (concat string-contents
					  (zzz-read-unicode-escape))))
	   ((eq c2 ?x)
	    (setq string-contents (concat string-contents
					  (zzz-read-hex-escape))))
	   ((zzz-eol-p c2)) ;;do nothing if escaped newline
	   ((eq c2 ?0)
	    (if (zzz-decimal-digits-start-p (zzz-peek-char))
		(error "Decimal digit not allowed after \\0.")
	      (setq string-contents (concat string-contents (string 0)))))
	   ((eq c2 ?b)
	    (setq string-contents (concat string-contents (string 8))))
	   ((eq c2 ?t)
	    (setq string-contents (concat string-contents (string 9))))
	   ((eq c2 ?n)
	    (setq string-contents (concat string-contents (string 10))))
	   ((eq c2 ?v)
	    (setq string-contents (concat string-contents (string 11))))
	   ((eq c2 ?f)
	    (setq string-contents (concat string-contents (string 12))))
	   ((eq c2 ?r)
	    (setq string-contents (concat string-contents (string 13))))
	   ((eq c2 ?\")
	    (setq string-contents (concat string-contents (string ?\"))))
	   ((eq c2 ?\')
	    (setq string-contents (concat string-contents (string ?\'))))
	   ((eq c2 ?\\)
	    (setq string-contents (concat string-contents (string ?\\))))
	   ((memq c2 "123456789")
	    (error "Invalid escape sequence."))
	   (t
	    (setq string-contents (concat string-contents (string c2)))))))))
    token))

(defun zzz-token-comment1 (comment)
  "Return a pseudo-token for a SingleLineComment based on `comment'.")

(defun zzz-token-process-comment1 ()
  "Return a pseudo-token for a single-line comment.
Do not consume the newline."
  (let ((c nil)
	(comment-string ""))
    (while (not (zzz-eol-p c))
      (setq c (zzz-get-char))
      (unless (zzz-eol-p c)
	(setq comment-string (concat comment-string (string c)))))
    (zzz-unget-char)
    (zzz-token-comment1 comment-string)))

(defun zzz-token-commentn (comment contains-newline)
  "Return a token for a MultiLineComment optionally containing a newline.")

(defun zzz-token-process-commentn ()
  "Return a pseudo-token for a multi-line comment."
  (let ((c nil)
	(comment-string "")
	(done-with-comment nil)
	(comment-state 0)
	(contains-newline nil))
    (while (not (done-with-comment))
      (setq c (zzz-get-char))
      (cond
       ((= comment-state 0)
	(cond
	 ((= c ?*)
	  (setq comment-state 1))
	 ((zzz-eol-p c)
	  (setq comment-string (concat comment-string (string c)))
	  (setq contains-newline t))
	 (t
	  (setq comment-string (concat comment-string (string c))))))
       ((= comment-state 1)
	(if (= c ?/)
	    (setq done-with-comment t)
	  (setq comment-string (concat comment-string "*"))
	  (setq comment-state 0)
	  (zzz-unget-char)))))
    (zzz-token-commentn comment-string contains-newline)))

(defun zzz-token-regex-non-terminator (c)
  "Return a token for RegularExpressionNonTerminator `c'."
  '(zzz-RegularExpressionNonTerminator (string c)))

(defun zzz-token-regex-escape (c)
  "Return a token for RegularExpressionBackslashSequence based on
character `c'."
  '(zzz-RegularExpressionBackslashSequence (string c)))

(defun zzz-token-regex-class (tokens)
  "Return a token for RegularExpressionClass containing its contents,
`tokens'."
  '(zzz-RegularExpressionClass tokens))

(defun zzz-token-process-regex-class (c)
  "Return a token for RegularExpressionClass starting with
character `c'."
  (let ((c nil)
	(done-with-class nil)
	(class-tokens nil))
    (while (not (done-with-class))
      (setq c (zzz-get-char))
      (cond
       ((= c ?\])
	(setq done-with-class t))
       ((= c ?\\)
	(let ((c2 (zzz-get-char)))
	  (if (zzz-regex-non-terminator-p c2)
	      (setq class-tokens
		    (cons (zzz-token-regex-escape c2) class-tokens))
	    (error "Line terminator in regex class."))))
       ((zzz-regex-non-terminator-p c)
	(setq class-tokens
	      (cons (zzz-token-regex-non-terminator c) class-tokens)))
       (t
	(error "Line terminator in regex class."))))
    (zzz-token-regex-class (reverse class-tokens))))

(defun zzz-token-process-regex (c)
  "Return regex token starting with character `c'."
  (let ((c nil)
	(done-with-regex nil)
	(regex-flags "")
	(regex-tokens nil))
    (while (not (done-with-regex))
      (setq c (zzz-get-char))
      (cond
       ((= c ?/)
	(setq done-with-regex t))
       ((= c ?\\)
	(let ((c2 (zzz-get-char)))
	  (if (zzz-regex-non-terminator-p c2)
	      (setq regex-tokens
		    (cons (zzz-token-regex-escape c2) regex-tokens))
	    (error "Line terminator in regex."))))
       ((= c ?\[)
	(setq regex-tokens
	      (cons (zzz-token-process-regex-class) regex-tokens)))
       ((zzz-regex-non-terminator-p c)
	(setq regex-tokens
	      (cons (zzz-token-regex-non-terminator c) regex-tokens)))
       (t
	(error "Line terminator in regex."))))
    (setq done-with-regex nil)
    (while (not (done-with-regex))
      (setq c (zzz-get-char))
      (if (zzz-identifier-part-p c)
	  (setq regex-flags (concat regex-flags (string c)))
	(zzz-unget-char)
	(setq done-with-regex t)))
    (zzz-token-regex (reverse regex-tokens) regex-flags)))

(defun zzz-token-punctuator (str)
  "Return a Punctuator token of the appropriate type based on `str'.")

(defun zzz-token-process-punctuator (c)
  "Return token starting with punctuator character `c'."
  (cond
   ((memq c "{}()[].;,~?:")
    (zzz-token-punctuator (string c)))
   ((memq c "<>")
    (let ((c2 (zzz-get-char)))
      (cond
       ((eq c2 ?\=)
	(zzz-token-punctuator (string c c2)))
       ((eq c2 c)
	(let ((c3 (zzz-get-char)))
	  (cond
	   ((eq c3 ?\=)
	    (zzz-token-punctuator (string c c2 c3)))
	   ((and (eq c3 c) (eq c ?\>))
	    (let ((c4 (zzz-get-char)))
	      (cond
	       ((eq c4 ?\=)
		(zzz-token-punctuator (string c c2 c3 c4)))
	       (t
		(zzz-unget-char)
		(zzz-token-punctuator (string c c2 c3))))))
	   (t
	    (zzz-unget-char)
	    (zzz-token-punctuator (string c c2))))))
       (t
	(zzz-unget-char)
	(zzz-token-punctuator (string c))))))
   ((memq c "!=")
    (let ((c2 (zzz-get-char)))
      (cond
       ((eq c2 ?\=)
	(let ((c3 (zzz-get-char)))
	  (cond
	   ((eq c3 ?\=)
	    (zzz-token-punctuator (string c c2 c3)))
	   (t
	    (zzz-unget-char)
	    (zzz-token-punctuator (string c c2))))))
       (t
	(zzz-unget-char)
	(zzz-token-punctuator (string c))))))
   ((memq c "*%^/")
    (let ((c2 (zzz-get-char)))
      (cond
       ((eq c2 ?\=)
	(zzz-token-punctuator (string c c2)))
       (t
	(zzz-unget-char)
	(zzz-token-punctuator (string c))))))
   ((memq c "+-&|")
    (let ((c2 (zzz-get-char)))
      (cond
       ((eq c2 c)
	(zzz-token-punctuator (string c c2)))
       ((eq c2 ?\=)
	(zzz-token-punctuator (string c c2)))
       (t
	(zzz-unget-char)
	(zzz-token-punctuator (string c))))))
   (t
    (error "Invalid punctuator somehow."))))

(defun zzz-token-process-eol (c)
  "Return eol token starting with character `c'."
  (cond
   ((memq c '(10 2028 2029))
    (zzz-eol-token (string c)))
   ((= c 13)
    (let ((c2 zzz-get-char))
      (if (= c2 10)
	  (zzz-eol-token (string c c2))
	(zzz-unget-char)
	(zzz-eol-token (string c)))))
   (t
    (error "Invalid eol somehow."))))

(deflocal zzz-regex-context-token-types
  '(zzz-DOT zzz-OPEN_PAREN zzz-COMMA zzz-OPEN_BRACE zzz-CLOSE_BRACE
	    zzz-OPEN_BRACKET zzz-SEMICOLON zzz-COMMA zzz-LESS
	    zzz-GREATER zzz-LESS_EQ zzz-GREATER-EQ zzz-EQ zzz-NOT_EQ
	    zzz-STRICT_EQ zzz-STRICT_NOT_EQ zzz-PLUS zzz-MINUS
	    zzz-STAR zzz-PERCENT zzz-PRE_INC zzz-PRE_DEC zzz-SHIFT_LEFT
	    zzz-SHIFT_RIGHT zzz-SHIFT_RIGHT_FILL zzz-BIT_AND zzz-BIT_OR
	    zzz-BIT_XOR zzz-NOT zzz-BIT_NOT zzz-AND zzz-OR zzz-QUES zzz-COLON
	    zzz-ASSIGN zzz-ASSIGN_PLUS zzz-ASSIGN_MINUS zzz-ASSIGN_STAR
	    zzz-ASSIGN_PERCENT zzz-ASSIGN_SHIFT_LEFT zzz-ASSIGN_SHIFT_RIGHT
	    zzz-ASSIGN_SHIFT_RIGHT_FILL zzz-ASSIGN_BIT_AND zzz-ASSIGN_BIT_OR
	    zzz-ASSIGN_BIT_XOR zzz-DIV zzz-ASSIGN_DIV)
  "The types of tokens preceding a regex context.
The lexer must distinguish between pre- and post- increment and decrement -
fortunately, they occupy very similar lexical space.")

(defun zzz-regex-context-p ()
  "Return whether the current context allows RegularExpressionLiteral
as opposed to the division operator."
  (memq (zzz-token-type (zzz-preceding-token)) zzz-regex-context-token-types))

(defun zzz-pre-context-p ()
  "Return whether the current context interprets a ++ or -- as a
pre-increment/decrement or a post-increment/decrement."
  (memq (zzz-token-type (zzz-preceding-token))
	(cons zzz-LineTerminator zzz-regex-context-token-types)))

(defun zzz-get-token ()
  "Return next token."
  (let ((c nil)
	(whitespace "")
	(comments-before nil)
	(continue t))
    (while continue
      (setq continue nil)
      (setq c (zzz-get-char))
      (cond
       ;; EOF special case
       ((eq c zzz-EOF_CHAR)
	(zzz-token-eof c))
       ;; EOL special case
       ((zzz-eol-p c)
	(zzz-token-process-eol c))
       ;; whitespace - record and keep going
       ((zzz-whitespace-p c)
	(setq continue t)
	(setq whitespace (concat whitespace (string c))))
       ;; backslash - must be IdentifierName start
       ((eq c ?\\)
	(if (not (zzz-match-char ?u))
	    (error "Invalid escape sequence")
	  (setq c (zzz-read-unicode-escape))
	  (if (zzz-identifier-start-p c)
	      (zzz-token-process-identifier c)
	    (error "Invalid IdentifierName start from escape sequence"))))
       ;; other IdentifierName
       ((zzz-identifier-start-p c)
	(zzz-token-process-identifier c))
       ;; NumericLiteral dot special case
       ((and (eq c ?\.) (zzz-decimal-digits-start-p (zzz-peek-char)))
	(zzz-token-process-numeric-literal c))
       ;; NumericLiteral
       ((zzz-numeric-literal-start-p c)
	(zzz-token-process-numeric-literal c))
       ;; StringLiteral
       ((or (eq c ?\') (eq c ?\"))
	(zzz-token-process-string-literal c))
       ;; comment special case before other slashes
       ((and (eq c ?\/) (memq (zzz-peek-char) "*/"))
	(let ((contains-newline nil)
	      (token nil)
	      (c2 (zzz-get-char)))
	  (cond
	   ((eq c2 ?\/)
	    (setq token (zzz-token-process-comment1))
	    (setq contains-newline t)
	    (if (zzz-comment1-alone-p)
		(setq comments-before (append comments-before token))
	      (zzz-append-comment1 token))
	    (zzz-token-eol c))
	   ((eq c2 ?\*)
	    (setq token (zzz-token-process-commentn))
	    (if contains-newline
		(zzz-token-commentn token)
	      (setq continue t)
	      (setq comments-before (append comments-before token))))
	   (t
	    (error "Invalid comment somehow.")))))
       ;; regex special case before punctuators
       ((and (eq c ?\/) (zzz-regex-context-p))
	(zzz-token-process-regex c))
       ;; punctuator including slash
       ((zzz-punctuator-start-p c)
	(zzz-token-process-punctuator c))))))

(defun zzz-tokenize ()
  "Returns a stream of tokens based on the current buffer."
  (let ((token nil)
	(tokens nil))
    (while (not (= (zzz-token-type token) zzz-EOF))
      (setq token (zzz-get-token))
      (setq tokens (cons token tokens)))
    (setq tokens (reverse tokens))))

(defun zzz-untokenize (tokens)
  "Prints out JS source code based on `tokens' to the current buffer.")

(zzz-tokenize)
